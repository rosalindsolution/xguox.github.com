
<!DOCTYPE HTML>
<html lang="en-GB">
<head>
	<meta charset="utf-8">
	<title>Coder & Jabber  | XguoX</title>

	<meta name="author" content="XguoX">

<meta name="description" content="总有人问,XXX跟YYY那个地方比较好玩.其实我觉得都要自己走过了才能评价,而且别人的评价不一定适合你.再说,我觉得城市跟城市没啥好比较的,各有各的风格韵味.而在一个城市里边不同的地方风格韵味也不一样. 在妖都呆了两年多了,都木有怎么好好的走过.除了偶尔去其他同学的学校串串门, &hellip;"> <meta name="keywords" content="">

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="XguoX" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	

</head>



<body>
	<header id="header" class="inner"><h1><a href="/">XguoX</a></h1>
<span class="tagline">Coder & Jabber</span>
<nav id="main-nav"><ul>
	<li><a href="http://www.flickr.com/photos/groverlu/sets" target="_blank">Flickr</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/atom.xml">RSS</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul>
	<li><a href="http://www.flickr.com/photos/groverlu/sets" target="_blank">Flickr</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/atom.xml">RSS</a></li>
</ul>
</div>
	</div>
</nav>


</header>

	<div id="content" class="inner">


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2011/12/23/20131224-guangzhou/">
			
				Diary:2011-12-23在妖都的一天</a>
		</h2>
		<div class="meta date">








  


<time datetime="2011-12-23T17:29:00+08:00" pubdate data-updated="true">Dec 23<span>rd</span>, 2011</time></div>
	</header>
	<div class="entry-content">
		<p>总有人问,XXX跟YYY那个地方比较好玩.其实我觉得都要自己走过了才能评价,而且别人的评价不一定适合你.再说,我觉得城市跟城市没啥好比较的,各有各的风格韵味.而在一个城市里边不同的地方风格韵味也不一样.</p>

<p>在妖都呆了两年多了,都木有怎么好好的走过.除了偶尔去其他同学的学校串串门,跑到北京路上下九这些走过N遍的街,再在天河城岗顶那些大商场转悠(虽说妖都的消费是贵,但是没人强迫你买东西撒,window shopping也不错的,还可以去一些什么苹果佳能数码体验店把玩下)&hellip;</p>

<p>记得之前去过最文艺的应该是小洲村了.&ldquo;流泪的咖啡&rdquo;,&ldquo;难喝的奶茶&rdquo;,&ldquo;蜜蜂喝过的绿茶&rdquo;&ldquo;三夏光年&rdquo;&hellip;嗯,想想现在好想到回去再瞧瞧&hellip;</p>

<p>因为烦闷了一个星期的考试,接着还要做各种课程设计,期末的小日子各种苦逼,于是昨天自己一个人一个包一部相机出门转悠去.</p>

<p>昨天的装束,让我觉得自己是一个像广州人的非广州人,像旅行者的常住者.背着包拿着相机四处张望,有种旅行者的范儿,但是熟练的搭地铁公交以及还算不错的粤语,又似乎,我就是一个地道的广州人.</p>

<p>第一站是&mdash;-方所书店&mdash;-貌似是11月末开张的&hellip;因为其文艺的气息让我慕名而来.其实我并不知道它的具体位置,只知道到地铁出口附近,跟着直觉走了几步居然就发现了.这并不是一个纯粹的书店,它融入了服侍cafe这些元素&hellip;最喜欢的是它的灯光,昏黄而富有情调.一开始我并没怎么放开,甚至有些蹑手蹑脚的,因为感觉在书店里摄影不太好,后来问过店员,他说&#8221;只要不要是靠近拍特写的那种,远远的拍是可以的&#8221;.最开始拍出来的那几张都没有那种调调和气息.后来把白平衡设置为日光后好多了.这里有许多来自港台国外的书籍,对于哪那一类的文艺青年,这里可以败到许多其他地方所没有的书籍.其实我并不是一个真正的文艺青年,对那些很文艺的青年大众小说不怎么带感.尽管这里很多的书并不适合我,不过还是看到好几本想要的书,好吧,期末的孩纸穷了,下次再来&hellip;一路充满我大脑的就两个字,文艺.重复的转悠了好几圈,也始终没有想要离开的欲望,若不是后面还有行程我想我可以花一个下午一整天的时间在这里.</p>

<p>离开方所直奔圣心教堂,走出海珠广场的地铁口,原本想凭直觉找到教堂的,但是失败了.最后不得不借助GPS&hellip;圣心教堂坐落在很多房屋中间,按照GPS的路线走了会才看到远处有一幢建筑的设计很特别.远远就看到了教堂的尖顶了.教堂内是不允许别人拍照的,但是进去之后貌似没人管理就偷偷拍了几张,后来,管理的阿姨从外面冲进来阻止了我们,有那么5~6个是光明正大的在拍.好吧,我觉得自己邪恶的玷污了教堂的神圣.所以没太用心去感受.有人说圣心比澳门的任何一间教堂都要宏伟&hellip;呃,我在澳门看过的教堂也不多,还是不做比较了.或者说,因为没有对教堂有什么认识,感觉都差不多吧.</p>

<p>在方所我尝试了各种白平衡,在圣心,则练习了各种曝光补偿&hellip; 好多时候,同一张照片拍了好多次,一级级的补偿直到满意为止.</p>

<p>我是个依赖地铁的人&mdash;-接下来是沙面,直转黄沙站.出站后依旧是凭着直觉的找到了.先是登上天桥四处张望,发现沙面的那个方向的建筑似乎比较的不同,而且人流相对来说比较旺盛一些.如果不是为了摄影我想我不会单独一个人跑来这里,并不是这里有什么不好,只是感觉这里适合跟朋友情人来,总之有伴儿来这会好一些.接近傍晚时分,测光各种出问题,我想我还是不太会利用光线.主要是这里的建筑都是欧式比较特殊吧,路上还遇上不少新人在拍摄结婚照片.我没有举起自己的相机也跟着拍,主要是因为,这些结婚的人跟我没啥关系,不管我最后照的好或坏,对我来说意义都不太深刻.当时,作为练习拍摄那个就另说吧&hellip;</p>

<p>冬日的5~6点真的没什么光线了,我也启程下一站.说实话,那时候的我真的好累,走了一整天还背着部单反.好吧,你们就说我的体质弱爆了吧.比较遗憾的是,这次出门身上带的钱不多,充了个羊城通就所剩无几了,所以没怎么尝到各地小食.连饭都没吃,饿啊&hellip;到了体育西站的时候,我在犹豫是直接回学校还是继续呢?话说当时地铁里那个人多啊,用举步维艰形容也不为过.最终,我还是决定坚持吧,反正都累了一整天不差继续累多会.于是来到了海心沙这边,这是我第二次来.也是我第一次单独一个人来.走出地铁时候外面天色已是完全的暗了!这里依旧的繁华,各种灯光扑朔迷离.因为临近圣诞,更加的热闹了.据说今晚貌似有节目,各种黄牛党在路上&#8221;要不要票,最低198啊..&ldquo;网上说有巨大的圣诞树看,不过貌似要门票进去,而且也不怎么巨吧.好想带个三脚架来这,夜晚手持拍摄始终不蛋定啊.直到那时我才发现,今天我的视角都是在地平线,啥时候找个高楼我想一定很壮观.只能等下次了&hellip;真的好累</p>

<p>尽管今天看似走了好多地方,但其实也仅仅是广州一角,我想,偌大一个城市,一定还有很多我没见到而很想见的地方.</p>

<p>相片在flickr,为自己的flickr打个小广告:<a href="http://www.flickr.com/photos/groverlu/">http://www.flickr.com/photos/groverlu/</a></p>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2011/12/08/error-rails-3-dot-1/">
			
				伤不起的Rails 3.1</a>
		</h2>
		<div class="meta date">








  


<time datetime="2011-12-08T17:14:00+08:00" pubdate data-updated="true">Dec 8<span>th</span>, 2011</time></div>
	</header>
	<div class="entry-content">
		<p>Maybe很多ror新人如我会跟着那个<a href="http://guides.RubyonRails.org/">Rails guide</a>小试牛刀搭一个自己的blog.一步步下来小有体会到Rails的强劲,也没出啥问题,到的comment那一块,X,对了半天源代码甚至复制粘贴到Sublime Text,奈何还是坑爹的冒出错误:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>undefined method `error_messages' for #&lt;ActionView::Helpers::FormBuilder:0x3bff910&gt;</span></code></pre></td></tr></table></div></figure>


<p>嗯,好吧,简体和繁体的guide都是基于Rails 3.0的.于是去官方看了下Rails 3.1的那个guide.很明显的,源代码少了<br/>
<code>"&lt;%= f.error_messages %&gt;"</code><br/>
这一行.删去后妥妥的&hellip;.<br/>
查了下<code>error_messages</code>这玩意的用处,没查到,有木有高端指教一下啊~~<br/>
好吧,顺便借机叹息一下,中文的ror资料更新的好慢啊,想看中文版的AWDWR第四版却迟迟不出.难不成真的要去看英文版的??最近看 github上的英文已经各种够吃力了!!<del>(>_&lt;)</del></p>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2011/11/18/proc-vs-lambda/">
			
				Lambda 和 Proc 的区别在哪儿</a>
		</h2>
		<div class="meta date">








  


<time datetime="2011-11-18T17:12:00+08:00" pubdate data-updated="true">Nov 18<span>th</span>, 2011</time></div>
	</header>
	<div class="entry-content">
		<p>proc是代码块的对象形式,它的行为就像一个代码块.Lambda的的行为略有不同,它的行为更像方法而非代码块.调用一个proc则像对代码块进行yield,而调用一个lambda则像调用一个方法.在Ruby1.9中的,可以通过Proc对象的实例方法 lambda? 来判定该实例是一个proc还是lambda,如果返回值为真,那么它是一个lambda,否则为一个proc.</p>

<h2>代码块、proc和lambda中的return语句</h2>

<p>在一个代码块中的return语句不仅仅会从调用代码块的迭代器返回,它还会从调用迭代器的方法返回.例如:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span>  <span class="nf">test</span>
</span><span class='line'>     <span class="nb">puts</span> <span class="s2">&quot;entering method&quot;</span>
</span><span class='line'>     <span class="mi">1</span><span class="o">.</span><span class="n">times</span><span class="p">{</span><span class="nb">puts</span> <span class="s2">&quot;entering block&quot;</span><span class="p">;</span><span class="k">return</span><span class="p">}</span>
</span><span class='line'>     <span class="nb">puts</span> <span class="s2">&quot;exiting method&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="nb">test</span>
</span></code></pre></td></tr></table></div></figure>


<p>proc与代码块类似,因此如果调用的proc执行一个return语句,它会试图从代码块(这个代码块被转换为一个proc)所在的方法中返回.比如:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>    <span class="k">def</span>  <span class="nf">test</span>
</span><span class='line'>            <span class="nb">puts</span> <span class="s2">&quot;entering method&quot;</span>
</span><span class='line'>            <span class="nb">p</span> <span class="o">=</span><span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span><span class="nb">puts</span>  <span class="s2">&quot;entering proc&quot;</span><span class="p">;</span><span class="k">return</span><span class="p">}</span>
</span><span class='line'>            <span class="nb">p</span><span class="o">.</span><span class="n">call</span>
</span><span class='line'>            <span class="nb">puts</span> <span class="s2">&quot;exiting method&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="nb">test</span>
</span></code></pre></td></tr></table></div></figure>


<p>不过,因为proc经常在不同方法间传递,在proc中使用return语句会十分诡异.在proc被调用时,在句法上包含该proc的方法已经返回:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>    <span class="k">def</span>   <span class="nf">procBuilder</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</span><span class='line'>            <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span><span class="nb">puts</span> <span class="n">message</span> <span class="p">;</span><span class="k">return</span><span class="p">}</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span>   <span class="nf">test</span>
</span><span class='line'>            <span class="nb">puts</span> <span class="s2">&quot;entering method&quot;</span>
</span><span class='line'>            <span class="nb">p</span> <span class="o">=</span> <span class="n">procBuilder</span><span class="p">(</span><span class="s2">&quot;entering proc&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="nb">p</span><span class="o">.</span><span class="n">call</span>
</span><span class='line'>            <span class="nb">puts</span> <span class="s2">&quot;exiting method&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="nb">test</span>
</span></code></pre></td></tr></table></div></figure>


<p>在把代码块转换成对象后,可以四处传递该对象,并且在&#8221;上下文&#8221;之外使用.如果这样做,则要承担从一个已经返回的方法中返回的风险.就像本例所示那样.当这种情况发生时,Ruby会抛出一个LocalJumpError异常.</p>

<p>当然,在这个臆造的例子中,可以通过去掉多余的return语句来修复这个问题.不过return语句并非总是多余的,这时可以通过使用lambda而非proc来修复这个问题.如前所述,lambda更像方法而非代码块.这样,在lambda中的return语句仅仅从lambda自身返回.而不会从产生lambda的方法中返回:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>    <span class="k">def</span>  <span class="nf">test</span>
</span><span class='line'>            <span class="nb">puts</span> <span class="s2">&quot;entering method&quot;</span>
</span><span class='line'>            <span class="nb">p</span> <span class="o">=</span> <span class="nb">lambda</span><span class="p">{</span><span class="nb">puts</span>  <span class="s2">&quot;entering lambda&quot;</span><span class="p">;</span><span class="k">return</span><span class="p">}</span>
</span><span class='line'>            <span class="nb">p</span><span class="o">.</span><span class="n">call</span>
</span><span class='line'>            <span class="nb">puts</span> <span class="s2">&quot;exiting method&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="nb">test</span>
</span></code></pre></td></tr></table></div></figure>


<p>Lambda中的return仅仅从lambda自身返回,这个事实意味着我们根本无须考虑LocalJumpError;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>    <span class="k">def</span>  <span class="nf">lambdaBuilder</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</span><span class='line'>            <span class="nb">lambda</span> <span class="p">{</span><span class="nb">puts</span> <span class="n">message</span><span class="p">;</span><span class="k">return</span><span class="p">}</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span>  <span class="nf">test</span>
</span><span class='line'>            <span class="nb">puts</span>   <span class="s2">&quot;exiting method&quot;</span>
</span><span class='line'>            <span class="n">l</span> <span class="o">=</span><span class="n">lambdaBuilder</span><span class="p">(</span><span class="s2">&quot;entering lambda&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">l</span><span class="o">.</span><span class="n">call</span>
</span><span class='line'>            <span class="nb">puts</span>  <span class="s2">&quot;exiting method&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="nb">test</span>
</span></code></pre></td></tr></table></div></figure>


<h2>代码块、proc和lambda中的break语句</h2>

<p>当我们用Proc.new创建一个proc对象时,这个Proc.new就是break语句应该返回的地方,当我们调用proc对象的时候,这个迭代器已经返回了,因此,用Proc.new创建一个顶级break语句是说不通的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>            <span class="k">def</span>  <span class="nf">test</span>
</span><span class='line'>                    <span class="nb">puts</span>  <span class="s2">&quot;entering test method &quot;</span>
</span><span class='line'>                    <span class="nb">proc</span> <span class="o">=</span><span class="no">Proc</span><span class="o">.</span><span class="n">new</span><span class="p">{</span><span class="nb">puts</span> <span class="s2">&quot;entering proc&quot;</span><span class="p">;</span><span class="k">break</span><span class="p">}</span>
</span><span class='line'>                    <span class="nb">proc</span><span class="o">.</span><span class="n">call</span>
</span><span class='line'>                    <span class="nb">puts</span>  <span class="s2">&quot;exiting test method&quot;</span>
</span><span class='line'>            <span class="k">end</span>
</span><span class='line'>            <span class="nb">test</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果通过迭代器方法的&amp;参数方式创建一个proc,我们可以调用它让该迭代器方法返回；</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>            <span class="k">def</span>  <span class="nf">iterator</span> <span class="p">(</span><span class="o">&amp;</span><span class="nb">proc</span><span class="p">)</span>
</span><span class='line'>                    <span class="nb">puts</span>  <span class="s2">&quot;entering iterator&quot;</span>
</span><span class='line'>                    <span class="nb">proc</span><span class="o">.</span><span class="n">call</span>
</span><span class='line'>                    <span class="nb">puts</span>  <span class="s2">&quot;exiting test method&quot;</span>
</span><span class='line'>            <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">def</span>  <span class="nf">test</span>
</span><span class='line'>                    <span class="n">iterator</span> <span class="p">{</span><span class="nb">puts</span> <span class="s2">&quot;entering proc&quot;</span><span class="p">;</span><span class="k">break</span><span class="p">)</span>
</span><span class='line'>            <span class="k">end</span>
</span><span class='line'>            <span class="nb">test</span>
</span></code></pre></td></tr></table></div></figure>


<p>Lambda类似于方法,因此,如果把一个break语句单独地放在那里,而不是出现在循环或者迭代方法中是说不通的.下面的语句,没有任何东西可以被break,你可能认为它会失败.
不过,在这种情况下,break的行为与return一样;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>            <span class="k">def</span>  <span class="nf">test</span>
</span><span class='line'>                    <span class="nb">puts</span> <span class="s2">&quot;entering test method&quot;</span>
</span><span class='line'>                    <span class="nb">lambda</span><span class="o">=</span><span class="nb">lambda</span><span class="p">{</span><span class="nb">puts</span> <span class="s2">&quot;entering lambda&quot;</span><span class="p">;</span><span class="k">break</span><span class="p">;</span><span class="nb">puts</span> <span class="s2">&quot;exiting    lambda&quot;</span><span class="p">}</span>
</span><span class='line'>                    <span class="nb">lambda</span><span class="o">.</span><span class="n">call</span>
</span><span class='line'>                    <span class="nb">puts</span> <span class="s2">&quot;exiting  test  method&quot;</span>
</span><span class='line'>              <span class="k">end</span>
</span><span class='line'>            <span class="nb">test</span>
</span></code></pre></td></tr></table></div></figure>


		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2011/11/18/flip-flop/">
			
				Flip-Flop</a>
		</h2>
		<div class="meta date">








  


<time datetime="2011-11-18T17:11:00+08:00" pubdate data-updated="true">Nov 18<span>th</span>, 2011</time></div>
	</header>
	<div class="entry-content">
		<p>今天学习到的一种比较新的,挺有趣的特性, 说新只是以前学JAVA和PHP的时候木有接触过.貌似Ruby的这一特性是从Perl那里继承而来,所以学习过Perl的程序员应该比较熟悉.</p>

<h2>flip-flop</h2>

<p>以下内容摘自<strong>《Ruby编程语言》</strong></p>

<blockquote><p>当..和&hellip;操作符被用在一个条件式,或者一个循环中时,它们不会创建Range对象.相反地,它们将创建一种特殊的布尔表达式,名为flip-flop.和比较以及相等表达式一样,一个flip-flop表达式的值也为true或者false.但是一个flip-flop表达式的特殊之处在于,它的值依赖于此前的求值结果,这就意味着flip-flop表达式具有与其关联的状态,所以你可能会认为一个flip-flop是一个某种类型的对象,但事实上flip-flop并不是对象,而是Ruby表达式.Ruby解释器在处理完一个flip-flop表达式之后,将为它在内部存储一个解析后的表现形式,其中就保存了该表达式的状态(只是作为一个布尔值).</p></blockquote>

<p>有了这些背景知识后,请看下面代码中的<code>flip-flop</code>.第一个<code>..</code>创建一个<code>Range</code>对象,第二个<code>..</code>则创建了一个<code>flip-flop</code>表达式:
<code>(1..10).each {|x| print x if x==3..x==5 }</code></p>

<blockquote><p>   在一个由条件式或者循环所构成的上下文中,一个flip-flop由两个通过..操作符相连的布尔表达式构成.除非其左侧表达式为true,否则一个flip-flop表达式就位false,而且在左侧表达式为true之前,它的值都会是false.</p>

<p>  一旦该表达式为true那么它就会&#8221;flips&#8221;到一个持久的true状态.它会保持该状态,而且对其后续的求值也返回true,直到其右侧的表达式为true为止.如果右侧表达式为 true了那么该flip-flop就会&#8221;flops&#8221;回一个持久的false状态,对其后续的求值也返回false,直到其左侧表达式再次成为true为止.</p>

<p>  在上面的代码例子中,该flip-flop被反复求值,相应的x的值也从1增加到10.起初,它的状态为false,而且在x等1和2的时候一直是false.当x等于3的时候,该flip-flop的状态就成为true.在x等于4和5的时候,该flip-flop的状态又回到了false,而且对于后续的x,它总是返回false.上述代码的执行结果是打印出345 .
可以使用..或&hellip;来编写flip-flop.起差别在于:当一个..flip-flop为true时,它会返回true,同时测试它的右侧表达式以决定是否需要将其内部状态设置回false；而对于&hellip;flip-flop来说,它等到下一次求值的时候才测试其右侧表达式.观察下面的代码:</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Prints &quot;3&quot;  .  Flips and flops back  when x==3</span>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">print</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">3</span><span class="o">.</span><span class="n">.x</span><span class="o">&gt;=</span><span class="mi">3</span><span class="p">}</span>
</span><span class='line'><span class="c1"># Print &quot;34&quot; .   Flis when x==3 and flops when x==4</span>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">print</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">3</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">x</span><span class="o">&gt;=</span><span class="mi">3</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注:flip-flop其中一个意思是突变,flip和flop都有翻转的意思</p>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2011/09/05/half-university-life/">
			
				1/2 的大学</a>
		</h2>
		<div class="meta date">








  


<time datetime="2011-09-05T17:29:00+08:00" pubdate data-updated="true">Sep 5<span>th</span>, 2011</time></div>
	</header>
	<div class="entry-content">
		<p>很久很久以前,曾经写过偶八分之一大学感想.才发现,原来,原来我第一天上大学也如今天一样是9月5号!!不过,今天是2011的9月5号!!也就意味着,我现在写的应该叫做我的二分之一大学感想!<br/>
有时候会觉得,我已经不是从前那个我,我还是从前那个我!! ╮(╯▽╰)╭我貌似又在说废话了! <br/>
前不久,一个舍友在电话里询问一位师兄关于咱们专业的未来发展问题!我感觉,那是大一的问题,甚至是我大一也懒得去问的问题!!小小的为他悲哀下!其实感觉他是太好学了!什么都想拥有,结果却在奋斗的路上迷路了!真的,当他说出那句&#8221;我想问下我们专业以后的发展…&#8221;我第一时间回想起大一!如果一早就有了自己的规划应该不会等到现在大三了还如此吧!<br/>
之前,我说,心,要决!那是要建立在有了自己的规划下,许多人总会用一句计划赶不上变化来为自己的不计划找借口!我自认为也是个随性的人,但是,规划的益处还是大大滴有啊!在我看来,做了规划不去努力履行会有良心在谴责自己!好像有点点夸张!不过我现在就有那么点那种感觉吧!<br/>
这个大二,应该会是大学四年最让我感到失败的一年!虽然依旧贯彻那些思想,依旧各种逃课,可却没有好好利用这逃来的课!!我是规划的不错,可是却没有好好努力去履行!!自学的进展比计划慢的多的多!以至于真的计划发生了变化! <br/>
大三,刚过去一个礼拜,一切似乎渐渐又步入正轨!!不知道能坚持到多久??先写着这么多吧,晚了,先睡去!!期待明天的聚餐!</p>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2010/01/18/review-i-am-c-r-7/">
			
				Review 《我是C罗》</a>
		</h2>
		<div class="meta date">








  


<time datetime="2010-01-18T17:33:00+08:00" pubdate data-updated="true">Jan 18<span>th</span>, 2010</time></div>
	</header>
	<div class="entry-content">
		<p>最近看了一本写c罗的书,作者是英国的<a href="http://www.amazon.cn/%E6%88%91%E6%98%AFC%E7%BD%97-%E6%B1%A4%E5%A7%86%C2%B7%E6%AC%A7%E8%8F%B2%E5%B0%94%E5%BE%B7/dp/B002BNLLXO/ref=sr_1_1?ie=UTF8&amp;qid=1383562705&amp;sr=8-1&amp;keywords=%E6%88%91%E6%98%AFC%E7%BD%97">汤姆.欧菲尔德</a>!当然是翻译成中文的啦!我暂时还没那么牛可以看英文版的,不过我相信不久的将来我可以!</p>

<p>回到话题吧!我不是足球迷,不怎么喜欢看足球,偶尔神神的话还是会看看的,06世界杯,无意中看到葡萄牙的比赛,无意中看到了克里斯蒂亚诺-罗纳尔多,无意中看到了他那些炫目如魔术般的脚法,真的被深深吸引了!以致于直到现在,足球比赛,只喜欢看有他存在的比赛,葡萄牙,过去的曼联,现在的皇马!而且,每次看都会在屏幕里面满场的寻找他的踪影!</p>

<p>我不懂足球,什么都不懂!但我喜欢看有他的比赛!看了欧菲尔德的这本&#8221;我是c罗&#8221;感悟很多,看到了他的成长与进步,失败与成功……很精彩!(娃啊,你抽了哪门子风,以前叫你写篇作文还要老师穷追猛追,现在还没事找事来个读后感伐!)</p>

<p>Cristiano Ronaldo 的童年就与足球结下了不解渊源,因为他有一个热爱足球的父亲,让他的过人的足球天赋早早就被发掘!因为这样的一个环境,他也开始了不平凡的人生!  天赋这样东西,很缥缈,很美好!或许其实我们每一个人都有着各式各样的天赋!只是没有被他人或自我早早的发现,更谈不上顺着这样的天赋起步!很幸运, c罗从小就被发掘出他在足球上的超人能力!也很幸运的被星探发现!从国民队到里斯本竞技再到曼联!很幸运他遇到了很多伯乐!尤其是弗格森!用慧眼识英雄再适合不过了!是他让c罗进入到了更广阔的平台!c罗能有今天,弗爵功不可没啊!</p>

<p>除了天赋,幸运,还有就是他对足球浓厚的兴趣,或许很多人听说过不计其数的一些关于兴趣对一个人的成功有多重要多关键的话语了!或许对那些话已经麻木了!可是我还是要说,如果不是兴趣做前奏,那成功了也隐隐充斥着不快!…我们大学生,进入到象牙塔中,这是很好的机会,就像c罗被星探们发现那样,我们也被各个不同的大学发掘了!我们在迈向成功的路上又前进了一小步!只要在我们感兴趣的专业、能力加以努力!总有一天会像c罗那样发光发热!</p>

<p>相比c罗十二岁就离开家庭这个温暖的怀抱独自一人在里斯本深造足球,  我们是幸福的也是不幸的!幸福因为我们可以更快乐、充分地享受童年、青春,不幸,  是因为我们不能像他那样早早面对社会,自力更生!很自然,  作为一个仅仅12岁的还没完全告别童年的小毛孩,  homesickness是肯定的!可是这也造就了c罗,  使他的适应力和承受力很大程度上得到强化!在首都踢球时,因为他的家乡口音,  使得他被其他一些队友排挤!但是,他依旧刻苦的训练,他坚信,终有一日,  他要用他娴熟甚至绝伦的技术封住那些嘲笑他的一切!  付出&mdash;&mdash;-回报!慢慢的,  他的光芒吸引了注意力,也慢慢的,有了一些名气,同时,  他要面临的种种也越来的充满挑战性!一路上,很多的小成功,但是他却没有满足,  他有着更远的梦想,一个男人的野心,  从不肯认输认弱!!葡萄牙国际知名守门员里卡多曾说为竞赛而生活,  c罗他就是一个!!此后的葡萄牙也因为他而发生巨大的进步!</p>

<p>虽然失败是难免的,刚到曼联的前两个赛季,球队的战绩并不十分理想,欧洲杯上,葡萄牙憾负希腊屈居亚军虽然这个成绩对于葡萄牙来说已经很不错了,但最后,他还是克制不住泪水,疯狂的洒在了绿荫场上,对成功的无尽渴望………他依旧坚持着一个远大的信念!小成功小失败没有阻止他对大信念的追求!06世界杯的鲁尼红牌事件又一次深深地给予C罗很多考验,这次事件过后他成了英国人的公敌!很自然的,那是一个人的本能,他要捍卫自己队友,他没必要逼迫鲁尼下场,鲁尼也是他在曼联的队友啊,如果因为他要通过把鲁尼罚下去而获得成功,那他即使胜利了也会受到灵魂的谴责!但就像欧菲尔德所说的,他没有在聚光灯下退缩,相反的以此作为动力激励自己成功!最终用更辉煌的成绩回击了那些充满恶意的嘘声!</p>

<p>在欧洲赛场上初露锋芒时,然而又一个问题困扰着他,媒体、裁判、对手称他使用假摔这样的烂招!即使在最近,又再一次掀起批斗C罗假摔的风波!呃…我不是资深的裁判员,我看不懂足球!但是,请问,有铭文规定在足球场上面不能摔倒吗?关于C罗在赛场上的摔倒,我不知道是不是真的是假摔,也没有任何一个人知道,除了他自己!他已经很成功了,还会做一些有损自己形象的行为吗?None of us know except himself!</p>

<p>06~07赛季,一个很耀眼的赛季,一直在进步的他获得了很多殊荣!虽然他的技术已达到顶峰状态,但是,在态度与风度上,他做的比刚出道时要好的多!曾经的他,在比赛中甚至可以愤怒到狠狠的掐着对手脖子!现在,他的态度,他的成熟,让他更接近完美!!面对众多媒体的口诛笔罚,控制情绪重要不要让情绪控制,他做到了!当然这对于一个年轻人尤其是易怒的人来说是很难的,需要不断的经历风霜的洗礼,才会蜕变成完美!对的,在用心经历过后,我们每个人都会或多、或少的获得一些进步!或许我们曾经被很多人嘲笑指责过,但如果我们因此而放弃,不但没有达到梦想还让嘲笑指责你的人暗自偷乐!何不把嘘声嘲讽变成激励前进的动力了!</p>

<p>或许是我个人偏爱C罗,所以语言上有些偏袒,但是,看到他现在的成功,我们还要说什么吗?我们不是应该多学些他的优秀吗?</p>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2010/01/16/1-slash-8-university-life/">
			
				1/8 的大学</a>
		</h2>
		<div class="meta date">








  


<time datetime="2010-01-16T17:31:00+08:00" pubdate data-updated="true">Jan 16<span>th</span>, 2010</time></div>
	</header>
	<div class="entry-content">
		<p>前不久就听到好多这样的声音〖大学过了八分之一〗&hellip;  额…好像是吧!我对这个说法不怎么敏感!</p>

<p>倒一想想,9月5号到现在,这段时光过得还真快啊,虽然每周还是7天每天还是24小时每小时还是60分钟每分钟,依旧是60秒!但是,这每周每天每时每秒好像与过去的有了很大的不同!对比起中学,好多好多的不同&mdash;&mdash;-没有了曾经管着你生活学习的班主任；晚上没有舍管催命般的叫你熄灯、叫你去睡觉禁止你在宿舍开卧谈会；学校里边大部分活动都是学生自发组织完成；我们也更多的与高年级的学长学姐有了一些交流,这在中学几乎是没有的；还有,O(∩_∩)O~甚至直到现在还不知道校长长什么样,完全看不到他老人家一眼；还有,很重要的一点,自学,无论学业还是其他能力,如果想混的好,自学能力起着无可取代的地位&hellip;&hellip;渐渐地,认识了好多来自五湖四海的新面孔,呃…虽然不能一一对应是哪个湖哪个海,其中,不乏认识好多非本班的!相比之下,在中学这是很少的.</p>

<p>上学后,师兄师姐告诫我们不要把大学想的太美好,其实不然,这是一个残酷的小社会；上学后,周围的同学都说跟想象中的差好远好远；上学后,我终于深深的感触到了传说中的大学!!呵呵…是我容易知足还是怎么的!大学,除了没有以前的死党在一起外我觉得很好很nice,这是真话!呃,或许是我热衷于自由,而大学正是给了我这样的自由才让我这样说的吧!!!生活、学习等等各方面都掌握在了我手上,我必须更努力地学会去适应、去创造.在大学,我经历的、学到的是中学那么久以来都没经历过的、没学到的!我成长了很多,看到了这个小社会,慢慢的学会要怎么融入当中,虽然真的有些残酷,但我很喜欢,这样才能让我锻炼、不断强化!其实,大学真的很美好!</p>

<p>很遗憾,我居然完全没有意识自己的喜欢,梦想,追求等等.不过,无论现在如何,我也慢慢地长进了,专业,其实真的并没有想象中那么重要,我相信我的能力,只要我想,我可以在任何一个圈子混的很出色!! 我真正地开始为我的未来想好多、努力好多.我会经常奔图书馆了,这在中学是不可能存在的事情,回想中学,我还不知道图书馆具体构造是怎样,在哪能借书,有什么手续.甚至自学一些课外的东西,其中很多甚至可以说暂时还扯不上任何关系!我知道,这样我既提升了我的自学能力,也学到很多技能,还可以充实我的大学生活.</p>

<p>当一些学生干部,不能在乎这个职位有多高,干了多少社会工作,不能只在乎干了多少,这些都只是表面工作!更重要的是在从事这些工作中你是怎么干,取得了那些成果,深入的程度如何,学会了什么…我承认,一开始上学,我仅仅是以一些好奇心去面试一些学生会啊团委啊的社团机构,但是很不幸,我没有足够的出色让他们选择我.后来,慢慢的,经过多次的面试锻炼,我加入了学校的另一个不那么出名的机构,诚然,那些能进入团委、学生会的同学他们是厉害的,他们在竞选那一刻在评委的眼中更闪更牛X,但是,很多的很多并不是那一刻就决定的!如果在大机构社团碌碌无为,无所事事,只求一个名头,那即使给你个主席书记也不能服众也不能带领大家完美的完成工作……这类进入学生会的只能说他们跑的比我前但是并不及我跑的快! 现在,经常有上级师兄师姐叫你写写这个活动什么的策划书、方案、总结什么的,这,在中学是几乎不可能有的情况,至少我是!</p>

<p>工作、未来、人生,现在应该、必须好好想想了!我不担心挂科,并不代表我不注重学习,在我的大学中,学习还是第一的,学习能力,学习做人,学习处事,未来的路还有好远好远!当然,我知道,现在才是我的大学刚起步,所以我还有很多等待着我去学习,我也知道,大学四年,是一段稍纵即逝的时光,所以,我必须好好珍惜,最大化的完善自己!</p>

<p>希望自己能够真正的学会,理解:<br/>
在这个世界上我们无法做伟大的事,我们只能怀抱着伟大的爱去做些小事.<br/>
与其通过告诉别人你自己的善举来冲淡这种积极的感觉,倒不如独享这一秘密以保留全部积极的感觉.<br/>
&ldquo;他们这样做在努力教我些什么呢?&rdquo; <br/>
&ldquo;一年后我还会在乎这件事情吗?&#8221;<br/>
宽容,并不是背弃自己的信仰,更不是代表软弱无能,那是璀璨的魅力.<br/>
如此烦恼还是解决不了问题,请不要再这样下去了.<br/>
&#8220;虽然只是铜牌,但是我还是想表扬一下自己&rdquo;</p>

		
		
	</div>

</article>

<nav id="pagenavi">
    
        <a href="/blog/page/10/" class="prev">Previous</a>
    
    
</nav>
</div>
	<footer id="footer" class="inner"><br>
<br>
<br>
<br>
&copy; 2013

    XguoX

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/hyphenator.js"></script>


<script type="text/javascript">
      var disqus_shortname = 'xguox';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-39166710-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>




</body>
<script>
  $(document).ready(function() {
  // Make images center
  $('p:has(img)').css('text-align', 'center');
  });
</script>
</html>
